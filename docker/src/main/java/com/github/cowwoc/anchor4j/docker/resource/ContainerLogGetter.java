package com.github.cowwoc.anchor4j.docker.resource;

import com.github.cowwoc.anchor4j.core.internal.util.ToStringBuilder;
import com.github.cowwoc.anchor4j.docker.internal.client.InternalDocker;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;

import static com.github.cowwoc.requirements11.java.DefaultJavaValidators.requireThat;
import static com.github.cowwoc.requirements11.java.DefaultJavaValidators.that;

/**
 * Retrieves a container's logs.
 */
public final class ContainerLogGetter
{
	private final InternalDocker client;
	private final String id;
	private boolean follow;
	private Instant since;
	private Instant until;
	private boolean timestamps;
	private int linesFromEnd = Integer.MAX_VALUE;
	private final Logger log = LoggerFactory.getLogger(ContainerLogGetter.class);

	/**
	 * Creates an instance.
	 *
	 * @param client the client configuration
	 * @param id     the container ID
	 */
	ContainerLogGetter(InternalDocker client, String id)
	{
		assert that(client, "client").isNotNull().elseThrow();
		assert that(id, "id").doesNotContainWhitespace().isNotEmpty().elseThrow();
		this.client = client;
		this.id = id;
	}

	/**
	 * Indicates that log entries should be streamed in real-time as they are generated by the container.
	 *
	 * @return this
	 */
	public ContainerLogGetter follow()
	{
		this.follow = true;
		return this;
	}

	/**
	 * Configures the streams to only return logs since the specified time. Defaults to {@code null}.
	 *
	 * @param since the start time or {@code null} to omit
	 * @return this
	 */
	public ContainerLogGetter since(Instant since)
	{
		this.since = since;
		return this;
	}

	/**
	 * Configures the streams to only return logs until the specified time. Defaults to {@code null}.
	 *
	 * @param until the end time or {@code null} to omit
	 * @return this
	 */
	public ContainerLogGetter until(Instant until)
	{
		this.until = until;
		return this;
	}

	/**
	 * Indicates that logs should include timestamps at the beginning of every log line.
	 *
	 * @return this
	 */
	public ContainerLogGetter timestamps()
	{
		this.timestamps = true;
		return this;
	}

	/**
	 * Configures the number of log lines to return relative to the end of the logs. By default, all lines are
	 * returned.
	 *
	 * @param linesFromEnd the number of lines or {@code Integer.MAX_VALUE} to return all lines
	 * @return this
	 * @throws IllegalArgumentException if {@code linesFromEnd} is negative
	 */
	public ContainerLogGetter linesFromEnd(int linesFromEnd)
	{
		requireThat(linesFromEnd, "linesFromEnd").isNotNegative();
		this.linesFromEnd = linesFromEnd;
		return this;
	}

	/**
	 * Streams the container's logs.
	 *
	 * @return the stream
	 * @throws IOException if an I/O error occurs. These errors are typically transient, and retrying the
	 *                     request may resolve the issue.
	 */
	public LogStreams stream() throws IOException
	{
		// https://docs.docker.com/reference/cli/docker/container/logs/
		List<String> arguments = new ArrayList<>(11);
		arguments.add("container");
		arguments.add("logs");
		if (follow)
			arguments.add("--follow");
		if (since != null)
		{
			arguments.add("--since");
			arguments.add(String.valueOf(since.toEpochMilli()));
		}
		if (until != null)
		{
			arguments.add("--until");
			arguments.add(String.valueOf(until.toEpochMilli()));
		}
		if (linesFromEnd < Integer.MAX_VALUE)
		{
			arguments.add("--tail");
			arguments.add(String.valueOf(linesFromEnd));
		}
		if (timestamps)
			arguments.add("--timestamps");
		arguments.add(id);
		ProcessBuilder processBuilder = client.getProcessBuilder(arguments);
		log.debug("Running: {}", processBuilder.command());
		Process process = processBuilder.start();
		return new LogStreams(process);
	}

	@Override
	public String toString()
	{
		return new ToStringBuilder().
			add("id", id).
			add("follow", follow).
			add("since", since).
			add("until", until).
			add("linesFromEnd", linesFromEnd).
			add("timestamps", timestamps).
			toString();
	}

	/**
	 * A container's stdout and stderr log streams.
	 */
	public static final class LogStreams
	{
		private final Process process;

		/**
		 * Creates log streams.
		 *
		 * @param process the docker process
		 */
		private LogStreams(Process process)
		{
			assert process != null;
			this.process = process;
		}

		/**
		 * Returns the container's standard output as a byte stream.
		 *
		 * @return the output log
		 */
		public InputStream getOutputStream()
		{
			return process.getInputStream();
		}

		/**
		 * Returns the container's standard output as a {@code BufferedReader}, using the host's default character
		 * encoding.
		 *
		 * @return the output log
		 */
		public BufferedReader getOutputReader()
		{
			return process.inputReader();
		}

		/**
		 * Returns the container's standard error as a byte stream.
		 *
		 * @return the error log
		 */
		public InputStream getErrorStream()
		{
			return process.getErrorStream();
		}

		/**
		 * Returns the container's standard error as a {@code BufferedReader}, using the host's default character
		 * encoding.
		 *
		 * @return the error log
		 */
		public BufferedReader getErrorReader()
		{
			return process.errorReader();
		}

		/**
		 * Blocks until the operation completes.
		 *
		 * @return the exit code returned by {@code docker logs}
		 * @throws InterruptedException if the thread is interrupted before the operation completes
		 */
		public int waitFor() throws InterruptedException
		{
			return process.waitFor();
		}
	}
}