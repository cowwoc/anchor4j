package com.github.cowwoc.docker.resource;

import com.github.cowwoc.docker.internal.client.InternalClient;
import com.github.cowwoc.docker.internal.util.LogListener;
import com.github.cowwoc.docker.internal.util.ToStringBuilder;
import com.github.cowwoc.docker.resource.Container.LogStreams;
import org.eclipse.jetty.client.Request;

import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.net.URI;
import java.time.Instant;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import static com.github.cowwoc.requirements10.java.DefaultJavaValidators.that;
import static org.eclipse.jetty.http.HttpMethod.GET;

public final class ContainerLogs
{
	private final InternalClient client;
	private final String id;
	private boolean follow = true;
	private boolean stdout = true;
	private boolean stderr = true;
	private Instant since;
	private Instant until;
	private boolean timestamps;
	private int linesFromEnd;

	/**
	 * Creates a new instance.
	 *
	 * @param client the client configuration
	 * @param id     the container ID
	 * @throws NullPointerException     if any of the arguments are null
	 * @throws IllegalArgumentException if {@code id} contains leading or trailing whitespace or is empty
	 */
	ContainerLogs(InternalClient client, String id)
	{
		assert that(client, "client").isNotNull().elseThrow();
		assert that(id, "id").isStripped().isNotEmpty().elseThrow();
		this.client = client;
		this.id = id;
	}

	/**
	 * Determines whether to stream log entries in real-time as they are generated by the container. Defaults to
	 * {@code true}.
	 *
	 * @param follow {@code true} to stream log entries in real-time as they are generated by the container, or
	 *               {@code false} to return only the logs up to the current point in time without streaming new
	 *               entries.
	 * @return this
	 */
	public ContainerLogs follow(boolean follow)
	{
		this.follow = follow;
		return this;
	}

	/**
	 * Determines whether to include output from stdout. Defaults to {@code true}.
	 *
	 * @param stdout {@code true} to include stdout
	 * @return this
	 */
	public ContainerLogs stdout(boolean stdout)
	{
		this.stdout = stdout;
		return this;
	}

	/**
	 * Determines whether to include output from stderr. Defaults to {@code true}.
	 *
	 * @param stderr {@code true} to include stderr
	 * @return this
	 */
	public ContainerLogs stderr(boolean stderr)
	{
		this.stderr = stderr;
		return this;
	}

	/**
	 * Configures the streams to only return logs since the specified time. Defaults to {@code null}.
	 *
	 * @param since the start time or {@code null} to omit
	 * @return this
	 */
	public ContainerLogs since(Instant since)
	{
		this.since = since;
		return this;
	}

	/**
	 * Configures the streams to only return logs until the specified time. Defaults to {@code null}.
	 *
	 * @param until the end time or {@code null} to omit
	 * @return this
	 */
	public ContainerLogs until(Instant until)
	{
		this.until = until;
		return this;
	}

	/**
	 * Configures the streams to add timestamps to every log line. Defaults to {@code false}.
	 *
	 * @param timestamps {@code true} to include timestamps
	 * @return this
	 */
	public ContainerLogs timestamps(boolean timestamps)
	{
		this.timestamps = timestamps;
		return this;
	}

	/**
	 * Configures the number of log lines to return relative to the end of the logs. By default, all lines are
	 * returned.
	 *
	 * @param linesFromEnd the number of lines or {@code Integer.MAX_VALUE} to return all lines
	 * @return this
	 */
	public ContainerLogs linesFromEnd(int linesFromEnd)
	{
		this.linesFromEnd = linesFromEnd;
		return this;
	}

	/**
	 * Begins streaming the logs.
	 *
	 * @return the logs
	 * @throws IOException          if an I/O error occurs. These errors are typically transient, and retrying
	 *                              the request may resolve the issue.
	 * @throws TimeoutException     if the request times out before receiving a response. This might indicate
	 *                              network latency or server overload.
	 * @throws InterruptedException if the thread is interrupted while waiting for a response. This can happen
	 *                              due to shutdown signals.
	 */
	public LogStreams stream() throws IOException, TimeoutException, InterruptedException
	{
		if (!stdout && !stderr)
			return new LogStreams(null, null, null);
		// https://docs.docker.com/reference/api/engine/version/v1.47/#tag/Container/operation/ContainerLogs
		URI uri = client.getServer().resolve("containers/" + id + "/logs");
		Request request = client.createRequest(uri);
		if (follow)
			request.param("follow", String.valueOf(follow));
		if (stdout)
			request.param("stdout", String.valueOf(stdout));
		if (stderr)
			request.param("stderr", String.valueOf(stderr));
		if (since != null)
			request.param("since", String.valueOf(since.toEpochMilli()));
		if (until != null)
			request.param("until", String.valueOf(until.toEpochMilli()));
		if (timestamps)
			request.param("timestamps", String.valueOf(timestamps));
		if (linesFromEnd == Integer.MAX_VALUE)
			request.param("tail", "all");
		else
			request.param("tail", String.valueOf(timestamps));
		request.method(GET);

		@SuppressWarnings("PMD.CloseResource")
		PipedOutputStream stdoutForWriting = new PipedOutputStream();
		@SuppressWarnings("PMD.CloseResource")
		PipedOutputStream stderrForWriting = new PipedOutputStream();
		@SuppressWarnings("PMD.CloseResource")
		PipedInputStream stdoutForReading = new PipedInputStream(stdoutForWriting);
		@SuppressWarnings("PMD.CloseResource")
		PipedInputStream stderrForReading = new PipedInputStream(stderrForWriting);
		LogStreams streams = new LogStreams(stdoutForReading, stderrForReading, request);
		LogListener logListener = new LogListener(client, stdoutForWriting, stderrForWriting, streams);
		client.send(request, logListener);
		if (!logListener.getRequestComplete().await(5, TimeUnit.MINUTES))
			throw new TimeoutException();
		return streams;
	}

	@Override
	public String toString()
	{
		return new ToStringBuilder().
			add("id", id).
			add("follow", follow).
			add("stdout", stdout).
			add("stderr", stderr).
			add("since", since).
			add("until", until).
			add("timestamps", timestamps).
			add("linesFromEnd", linesFromEnd).
			toString();
	}
}