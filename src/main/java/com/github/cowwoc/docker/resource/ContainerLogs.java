package com.github.cowwoc.docker.resource;

import com.github.cowwoc.docker.internal.client.InternalClient;
import com.github.cowwoc.docker.internal.util.LogListener;
import com.github.cowwoc.docker.internal.util.RequestAbortedException;
import com.github.cowwoc.docker.internal.util.ToStringBuilder;
import com.github.cowwoc.pouch.core.WrappedCheckedException;
import org.eclipse.jetty.client.Request;

import java.io.IOException;
import java.io.InputStream;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.net.URI;
import java.time.Instant;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;

import static com.github.cowwoc.requirements10.java.DefaultJavaValidators.requireThat;
import static com.github.cowwoc.requirements10.java.DefaultJavaValidators.that;
import static org.eclipse.jetty.http.HttpMethod.GET;

public final class ContainerLogs
{
	private final InternalClient client;
	private final String id;
	private boolean follow = true;
	private boolean stdout = true;
	private boolean stderr = true;
	private Instant since;
	private Instant until;
	private boolean timestamps;
	private int linesFromEnd;

	/**
	 * Creates a new instance.
	 *
	 * @param client the client configuration
	 * @param id     the container ID
	 * @throws NullPointerException     if any of the arguments are null
	 * @throws IllegalArgumentException if {@code id} contains leading or trailing whitespace or is empty
	 */
	ContainerLogs(InternalClient client, String id)
	{
		assert that(client, "client").isNotNull().elseThrow();
		assert that(id, "id").isStripped().isNotEmpty().elseThrow();
		this.client = client;
		this.id = id;
	}

	/**
	 * Determines whether to stream log entries in real-time as they are generated by the container. Defaults to
	 * {@code true}.
	 *
	 * @param follow {@code true} to stream log entries in real-time as they are generated by the container, or
	 *               {@code false} to return only the logs up to the current point in time without streaming new
	 *               entries.
	 * @return this
	 */
	public ContainerLogs follow(boolean follow)
	{
		this.follow = follow;
		return this;
	}

	/**
	 * Determines whether to include output from stdout. Defaults to {@code true}.
	 *
	 * @param stdout {@code true} to include stdout
	 * @return this
	 */
	public ContainerLogs stdout(boolean stdout)
	{
		this.stdout = stdout;
		return this;
	}

	/**
	 * Determines whether to include output from stderr. Defaults to {@code true}.
	 *
	 * @param stderr {@code true} to include stderr
	 * @return this
	 */
	public ContainerLogs stderr(boolean stderr)
	{
		this.stderr = stderr;
		return this;
	}

	/**
	 * Configures the streams to only return logs since the specified time. Defaults to {@code null}.
	 *
	 * @param since the start time or {@code null} to omit
	 * @return this
	 */
	public ContainerLogs since(Instant since)
	{
		this.since = since;
		return this;
	}

	/**
	 * Configures the streams to only return logs until the specified time. Defaults to {@code null}.
	 *
	 * @param until the end time or {@code null} to omit
	 * @return this
	 */
	public ContainerLogs until(Instant until)
	{
		this.until = until;
		return this;
	}

	/**
	 * Configures the streams to add timestamps to every log line. Defaults to {@code false}.
	 *
	 * @param timestamps {@code true} to include timestamps
	 * @return this
	 */
	public ContainerLogs timestamps(boolean timestamps)
	{
		this.timestamps = timestamps;
		return this;
	}

	/**
	 * Configures the number of log lines to return relative to the end of the logs. By default, all lines are
	 * returned.
	 *
	 * @param linesFromEnd the number of lines or {@code Integer.MAX_VALUE} to return all lines
	 * @return this
	 */
	public ContainerLogs linesFromEnd(int linesFromEnd)
	{
		this.linesFromEnd = linesFromEnd;
		return this;
	}

	/**
	 * Begins streaming the logs.
	 *
	 * @return the logs
	 * @throws IOException          if an I/O error occurs. These errors are typically transient, and retrying
	 *                              the request may resolve the issue.
	 * @throws TimeoutException     if the request times out before receiving a response. This might indicate
	 *                              network latency or server overload.
	 * @throws InterruptedException if the thread is interrupted while waiting for a response. This can happen
	 *                              due to shutdown signals.
	 */
	public Streams stream() throws IOException, TimeoutException, InterruptedException
	{
		if (!stdout && !stderr)
			return new Streams(null, null, null);
		// https://docs.docker.com/reference/api/engine/version/v1.47/#tag/Container/operation/ContainerLogs
		URI uri = client.getServer().resolve("containers/" + id + "/logs");
		Request request = client.createRequest(uri);
		if (follow)
			request.param("follow", String.valueOf(follow));
		if (stdout)
			request.param("stdout", String.valueOf(stdout));
		if (stderr)
			request.param("stderr", String.valueOf(stderr));
		if (since != null)
			request.param("since", String.valueOf(since.toEpochMilli()));
		if (until != null)
			request.param("until", String.valueOf(until.toEpochMilli()));
		if (timestamps)
			request.param("timestamps", String.valueOf(timestamps));
		if (linesFromEnd == Integer.MAX_VALUE)
			request.param("tail", "all");
		else
			request.param("tail", String.valueOf(timestamps));
		request.method(GET);

		@SuppressWarnings("PMD.CloseResource")
		PipedOutputStream stdoutForWriting = new PipedOutputStream();
		@SuppressWarnings("PMD.CloseResource")
		PipedOutputStream stderrForWriting = new PipedOutputStream();
		@SuppressWarnings("PMD.CloseResource")
		PipedInputStream stdoutForReading = new PipedInputStream(stdoutForWriting);
		@SuppressWarnings("PMD.CloseResource")
		PipedInputStream stderrForReading = new PipedInputStream(stderrForWriting);
		Streams streams = new Streams(stdoutForReading, stderrForReading, request);
		LogListener logListener = new LogListener(client, stdoutForWriting, stderrForWriting, streams);
		client.send(request, logListener);
		if (!logListener.getRequestComplete().await(5, TimeUnit.MINUTES))
			throw new TimeoutException();
		return streams;
	}

	@Override
	public String toString()
	{
		return new ToStringBuilder().
			add("id", id).
			add("follow", follow).
			add("stdout", stdout).
			add("stderr", stderr).
			add("since", since).
			add("until", until).
			add("timestamps", timestamps).
			add("linesFromEnd", linesFromEnd).
			toString();
	}

	/**
	 * A container's log streams.
	 */
	public static final class Streams implements AutoCloseable
	{
		private final InputStream stdout;
		private final InputStream stderr;
		private final Request request;
		private final BlockingQueue<Throwable> exceptions = new LinkedBlockingQueue<>();
		private final AtomicBoolean closed = new AtomicBoolean();

		/**
		 * Creates a new instance.
		 *
		 * @param stdout  the container's standard output stream, or {@code null} if not captured
		 * @param stderr  the container's standard error stream, or {@code null} if not captured (or included as
		 *                part of {@code stdout})
		 * @param request the client request, or {@code null} if none of the streams were captured
		 */
		private Streams(InputStream stdout, InputStream stderr, Request request)
		{
			this.stdout = stdout;
			this.stderr = stderr;

			requireThat(request, "request").isNotNull();
			this.request = request;
		}

		/**
		 * Returns the container's standard output stream.
		 *
		 * @return {@code null} if the stream was not captured
		 */
		public InputStream getStdout()
		{
			return stdout;
		}

		/**
		 * Returns the container's standard error stream.
		 *
		 * @return {@code null} if the stream was not captured
		 */
		public InputStream getStderr()
		{
			return stderr;
		}

		/**
		 * Returns the errors encountered during the operation. Errors are added asynchronously as they occur. No
		 * new errors will be added after {@link #stopCapturing()} is invoked.
		 *
		 * @return the errors
		 * @see #stopCapturing()
		 */
		public BlockingQueue<Throwable> getExceptions()
		{
			return exceptions;
		}

		/**
		 * Stops capturing the streams.
		 *
		 * @throws InterruptedException if the thread is interrupted before the request is aborted
		 */
		public void stopCapturing() throws InterruptedException
		{
			if (request != null)
			{
				CountDownLatch onComplete = new CountDownLatch(1);
				try
				{
					if (request.abort(new RequestAbortedException(onComplete)).get())
						onComplete.await();
				}
				catch (ExecutionException e)
				{
					throw WrappedCheckedException.wrap(e);
				}
			}
		}

		/**
		 * Stops capturing the streams.
		 *
		 * @throws IOException if any of the streams throw an {@code IOException} while closing
		 */
		@Override
		@SuppressWarnings("EmptyTryBlock")
		public void close() throws IOException
		{
			if (!closed.compareAndSet(false, true))
				return;
			try (stdout; stderr)
			{
			}
		}
	}
}